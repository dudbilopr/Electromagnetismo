<!DOCTYPE html>
<html lang="es" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Campo Eléctrico: Eje de un Anillo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-light: #f8fafc; --bg-dark: #0f172a;
            --text-light: #1e2b3b; --text-dark: #e2e8f0;
            --border-light: #e2e8f0; --border-dark: #334155;
            --panel-light: #ffffff; --panel-dark: #1e2b3b;
            --accent-color: #3b82f6; --tab-inactive-light: #f1f5f9;
            --tab-inactive-dark: #334155;
        }
        html.dark {
            --bg-light: #0f172a; --text-light: #e2e8f0;
            --border-light: #334155; --panel-light: #1e2b3b;
            --tab-inactive-light: #334155;
        }
        body {
            font-family: 'Inter', sans-serif; background-color: var(--bg-light);
            color: var(--text-light); transition: background-color 0.3s, color 0.3s;
        }
        .panel {
            background-color: var(--panel-light); border: 1px solid var(--border-light);
            transition: background-color 0.3s, border-color 0.3s;
        }
        .tab-content { display: none; } .tab-content.active { display: block; }
        .tab-button { background-color: var(--tab-inactive-light); color: var(--text-light); }
        .tab-button.active { background-color: var(--accent-color); color: white; }
        html.dark .tab-button { color: var(--text-dark); }
        html.dark .tab-button.active { color: white; }
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            background: transparent; cursor: pointer; width: 100%;
        }
        input[type="range"]::-webkit-slider-runnable-track { height: 0.5rem; border-radius: 0.25rem; background: var(--border-light); }
        input[type="range"]::-moz-range-track { height: 0.5rem; border-radius: 0.25rem; background: var(--border-light); }
        input[type="range"]::-webkit-slider-thumb {
           -webkit-appearance: none; appearance: none; margin-top: -0.25rem;
           width: 1rem; height: 1rem; border-radius: 9999px; background-color: var(--accent-color);
        }
        input[type="range"]::-moz-range-thumb {
            width: 1rem; height: 1rem; border-radius: 9999px;
            background-color: var(--accent-color); border: none;
        }
    </style>
</head>
<body class="min-h-screen p-4 flex items-center justify-center">

<div class="w-full max-w-screen-2xl mx-auto flex flex-col lg:flex-row gap-4">
    <!-- Main Simulation Area -->
    <main class="flex-grow flex flex-col items-center justify-center panel rounded-xl shadow-lg p-4">
        <h1 class="text-2xl font-bold text-center mb-4 text-blue-600 dark:text-blue-400">Campo Eléctrico en el Eje de un Anillo Cargado (3D)</h1>
        <div id="canvas-parent" class="w-full h-[60vh] lg:h-full cursor-move">
            <canvas id="simulationCanvas"></canvas>
        </div>
    </main>

    <!-- Control and Information Panel -->
    <aside class="w-full lg:w-[550px] flex-shrink-0">
        <div class="panel rounded-xl shadow-lg p-4">
             <nav class="flex space-x-1 rounded-lg bg-slate-100 dark:bg-slate-900 p-1 mb-4">
                <button data-tab="controles" class="tab-button w-full text-sm font-semibold p-2 rounded-md">Controles</button>
                <button data-tab="datos" class="tab-button w-full text-sm font-semibold p-2 rounded-md">Datos</button>
                <button data-tab="teoria" class="tab-button w-full text-sm font-semibold p-2 rounded-md">Teoría</button>
                <button data-tab="analisis" class="tab-button w-full text-sm font-semibold p-2 rounded-md">Análisis</button>
            </nav>
            <div>
                <div id="controles" class="tab-content">
                    <p class="text-xs text-center text-slate-500 mb-3">Arrastra el punto P en la simulación o usa los sliders.</p>
                    <div class="my-3">
                        <label for="radiusSlider" class="block text-sm font-medium">Radio del anillo ($a$): <span id="radiusValue">1.0</span> m</label>
                        <input id="radiusSlider" type="range" min="0.5" max="2" value="1" step="0.1" class="w-full">
                    </div>
                     <div class="my-3">
                        <label for="x0Slider" class="block text-sm font-medium">Posición en el eje ($x_0$): <span id="x0Value">1.5</span> m</label>
                        <input id="x0Slider" type="range" min="0" max="4" value="1.5" step="0.1" class="w-full">
                    </div>
                    <div class="my-3">
                        <label for="densitySlider" class="block text-sm font-medium">Densidad lineal ($\lambda$): <span id="densityValue">5.0</span> nC/m</label>
                        <input id="densitySlider" type="range" min="1" max="10" value="5" step="0.1" class="w-full">
                    </div>
                    <div class="my-3">
                        <label for="dqAngleSlider" class="block text-sm font-medium">Posición de $dq$ ($\phi$): <span id="dqAngleValue">45</span>°</label>
                        <input id="dqAngleSlider" type="range" min="0" max="360" value="45" step="1" class="w-full">
                    </div>
                     <div class="grid grid-cols-2 gap-2 mt-4">
                        <button id="chargeSignBtn" class="p-2 rounded-lg font-semibold bg-red-500 text-white">Carga Positiva</button>
                        <button id="resetBtn" class="p-2 rounded-lg font-semibold bg-gray-500 hover:bg-gray-600 text-white">Reiniciar</button>
                    </div>
                    <div class="mt-4 flex items-center justify-center">
                        <span class="mr-2 text-sm font-medium">Claro</span>
                        <label for="theme-toggle" class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" value="" id="theme-toggle" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                        <span class="ml-2 text-sm font-medium">Oscuro</span>
                    </div>
                </div>

                <div id="datos" class="tab-content p-2 text-sm">
                    <p class="font-semibold text-base mb-2">Valores Infinitesimales (de $dq$)</p>
                    <div class="space-y-2 pl-2">
                        <p>Distancia $r$: <span id="rValue" class="font-mono font-semibold text-blue-600 dark:text-blue-400">...</span> m</p>
                        <p>Campo $|d\vec{E}|$: <span id="dEValue" class="font-mono font-semibold text-blue-600 dark:text-blue-400">...</span> N/C</p>
                        <p>Componente Axial $dE_x$: <span id="dExValue" class="font-mono font-semibold text-blue-600 dark:text-blue-400">...</span> N/C</p>
                    </div>
                    <hr class="my-4 border-slate-200 dark:border-slate-700">
                    <p class="font-semibold text-base mb-2">Valores Totales del Anillo</p>
                     <div class="space-y-2 pl-2">
                        <p>Carga Total $Q$: <span id="QValue" class="font-mono font-semibold text-purple-600 dark:text-purple-400">...</span> C</p>
                        <p>Campo Total $|\vec{E}_{total}|$: <span id="EtotalValue" class="font-mono font-semibold text-purple-600 dark:text-purple-400">...</span> N/C</p>
                    </div>
                </div>
                
                <div id="teoria" class="tab-content p-2 text-sm space-y-3">
                     <p class="font-semibold text-base">1. Campo de un Elemento $dq$</p>
                    <p>Un elemento de carga $dq$ en el anillo crea un campo $d\vec{E}$ en el punto P.</p>
                     <p class="text-center my-1 p-2 border rounded-md">$$d\vec{E} = k_e \frac{dq}{r^2} \hat{r} \quad \text{donde } r = \sqrt{a^2 + x_0^2}$$</p>
                    
                    <p class="font-semibold text-base">2. Descomposición y Simetría</p>
                    <p>El vector $d\vec{E}$ tiene una componente axial ($dE_x$) y una perpendicular ($dE_\perp$). Por cada $dq$, existe un $dq'$ opuesto cuyo campo $d\vec{E}'$ tiene una componente $dE'_\perp$ que cancela a la primera. <strong>Solo las componentes axiales ($dE_x$) sobreviven a la suma</strong>.</p>
                     <p class="text-center my-1 p-2 border rounded-md">$$dE_x = |d\vec{E}| \cos(\theta) = k_e \frac{dq}{r^2} \frac{x_0}{r}$$</p>

                    <p class="font-semibold text-base">3. Integración</p>
                    <p>Sumamos (integramos) $dE_x$ para todo el anillo. Como $k_e, x_0, r$ son constantes, la integral de $dq$ es la carga total $Q$.</p>
                     <p class="text-center my-1 p-2 border rounded-md">$$E_x = \int dE_x = \frac{k_e x_0}{r^3} \int dq = \frac{k_e Q x_0}{(a^2+x_0^2)^{3/2}}$$</p>
                     <p class="font-semibold text-base">4. Resultado Final</p>
                      <p>El campo total apunta a lo largo del eje x:</p>
                      <p class="text-center my-1 p-2 border rounded-md">$$ \vec{E} = \frac{k_e Q x_0}{(a^2+x_0^2)^{3/2}} \hat{i} $$</p>
                </div>
                
                <div id="analisis" class="tab-content p-2 text-sm space-y-4">
                     <p class="font-semibold text-base">Tips Conceptuales</p>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong>Centro del anillo ($x_0=0$):</strong> El campo eléctrico es CERO. Los vectores $d\vec{E}$ de puntos opuestos se cancelan perfectamente. Usa el slider para verlo.</li>
                        <li><strong>Muy lejos del anillo ($x_0 \gg a$):</strong> El anillo se comporta como una carga puntual. La fórmula se simplifica a $E \approx k_e Q / x_0^2$.</li>
                        <li><strong>Campo Máximo:</strong> El campo no es máximo ni en el centro ni en el infinito, sino en un punto intermedio.</li>
                    </ul>

                     <div class="mt-6">
                        <p class="font-semibold text-base">Desafío: Campo Máximo</p>
                        <div class="mt-2 p-3 border border-blue-200 dark:border-blue-800 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                            <p>Para un anillo de radio $a$, el campo eléctrico en el eje es máximo en la posición $x_0 = a / \sqrt{2}$.</p>
                            <p class="font-semibold my-2">Comprueba este resultado:</p>
                            <ol class="list-decimal list-inside my-2 pl-4">
                                <li>Fija el radio $a=1.0$ m.</li>
                                <li>Calcula la posición teórica del campo máximo ($x_0 \approx 0.707$ m).</li>
                                <li>Usa el slider para mover el punto P a esa posición y observa el valor del campo.</li>
                                <li>Mueve P a posiciones ligeramente mayores y menores para confirmar.</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </aside>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- STATE AND CONSTANTS ---
    const k = 8.9875517923e9;
    const initialState = {
        a: 1.0, x0: 1.5, lambda: 5.0,
        chargeSign: 1, dqAngle: Math.PI / 4,
    };
    let state = { ...initialState };

    // --- DOM ELEMENTS ---
    const radiusSlider = document.getElementById('radiusSlider'), radiusValue = document.getElementById('radiusValue');
    const x0Slider = document.getElementById('x0Slider'), x0Value = document.getElementById('x0Value');
    const densitySlider = document.getElementById('densitySlider'), densityValue = document.getElementById('densityValue');
    const dqAngleSlider = document.getElementById('dqAngleSlider'), dqAngleValue = document.getElementById('dqAngleValue');
    const chargeSignBtn = document.getElementById('chargeSignBtn'), resetBtn = document.getElementById('resetBtn');
    const rValueEl = document.getElementById('rValue'), dEValueEl = document.getElementById('dEValue');
    const dExValueEl = document.getElementById('dExValue'), QValueEl = document.getElementById('QValue');
    const EtotalValueEl = document.getElementById('EtotalValue');

    // --- 3D SCENE SETUP ---
    const canvas = document.getElementById('simulationCanvas');
    const canvasParent = document.getElementById('canvas-parent');
    let scene, camera, renderer, controls, ring, pointP, dqElement, dqElement2;
    let vectorGroup, E_total_vector;
    let line1, line2;
    let raycaster, mouse, dragPlane, draggedObject = null;

    function init3D() {
        scene = new THREE.Scene();
        const rect = canvasParent.getBoundingClientRect();

        camera = new THREE.PerspectiveCamera(75, rect.width / rect.height, 0.1, 1000);
        camera.position.set(2, 2, 3);

        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(rect.width, rect.height);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const ringMaterial = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide });
        const ringGeometry = new THREE.TorusGeometry(1, 0.03, 16, 100);
        ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.y = Math.PI / 2;
        scene.add(ring);

        const pointGeo = new THREE.SphereGeometry(0.08, 16, 16);
        pointP = new THREE.Mesh(pointGeo, new THREE.MeshBasicMaterial({ color: 0x10b981 }));
        scene.add(pointP);
        
        const dqGeo = new THREE.SphereGeometry(0.05, 16, 16);
        dqElement = new THREE.Mesh(dqGeo, new THREE.MeshBasicMaterial({ color: 0xf97316 }));
        dqElement2 = new THREE.Mesh(dqGeo, new THREE.MeshBasicMaterial({ color: 0xf97316 }));
        scene.add(dqElement, dqElement2);
        
        vectorGroup = new THREE.Group();
        scene.add(vectorGroup);
        
        E_total_vector = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1, 0xa855f7, 0.25, 0.12);
        scene.add(E_total_vector);

        const dashedMaterial = new THREE.LineDashedMaterial({ color: 0x64748b, dashSize: 0.1, gapSize: 0.05 });
        const lineGeom1 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
        const lineGeom2 = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
        line1 = new THREE.Line(lineGeom1, dashedMaterial);
        line2 = new THREE.Line(lineGeom2, dashedMaterial);
        scene.add(line1, line2);
        
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        dragPlane = new THREE.Plane();
        
        renderer.domElement.addEventListener('mousedown', onMouseDown, false);
        renderer.domElement.addEventListener('mousemove', onMouseMove, false);
        renderer.domElement.addEventListener('mouseup', onMouseUp, false);

        window.addEventListener('resize', onWindowResize);
        animate();
    }

    function onWindowResize() {
        const rect = canvasParent.getBoundingClientRect();
        camera.aspect = rect.width / rect.height;
        camera.updateProjectionMatrix();
        renderer.setSize(rect.width, rect.height);
    }
    
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    function calculateFields() {
        const { a, x0, lambda, chargeSign } = state;
        const Q = chargeSign * lambda * 1e-9 * 2 * Math.PI * a;
        const r = Math.hypot(a, x0);
        const E_total = (k * Q * x0) / Math.pow(r, 3);
        const dl = 0.05; 
        const dq = lambda * 1e-9 * dl;
        const dE_mag = (k * dq) / (r * r);
        const cos_theta = x0 / r;
        const dEx = dE_mag * cos_theta;
        return { r, dE_mag, dEx, Q, E_total };
    }

    function updateScene() {
        const { a, x0, dqAngle, chargeSign } = state;
        const fields = calculateFields();

        ring.scale.set(a, a, a);
        pointP.position.set(x0, 0, 0);

        const dq_y = a * Math.sin(dqAngle);
        const dq_z = a * Math.cos(dqAngle);
        dqElement.position.set(0, dq_y, dq_z);
        dqElement2.position.set(0, -dq_y, -dq_z);

        const isDark = document.documentElement.classList.contains('dark');
        scene.background = new THREE.Color(isDark ? 0x0f172a : 0xf8fafc);
        const chargeColor = chargeSign > 0 ? 0xef4444 : 0x3b82f6;
        ring.material.color.set(chargeColor);
        
        const vectorScale = 0.5 / Math.max(1e-9, fields.dE_mag);
        const P_pos = pointP.position;

        // Clear old vectors
        while(vectorGroup.children.length){ vectorGroup.remove(vectorGroup.children[0]); }

        // --- Create new vectors for dq1 ---
        const dq1_pos = dqElement.position;
        const dir1 = new THREE.Vector3().subVectors(P_pos, dq1_pos);
        if (chargeSign < 0) dir1.negate();
        dir1.normalize();
        
        const dE_vec = new THREE.ArrowHelper(dir1, P_pos, fields.dE_mag * vectorScale, chargeColor, 0.2, 0.1);
        
        const dir_perp1 = new THREE.Vector3(0, dir1.y, dir1.z).normalize();
        const dE_perp_mag = fields.dE_mag * Math.sin(Math.acos(state.x0/fields.r));
        const dE_perp_vec = new THREE.ArrowHelper(dir_perp1, P_pos, dE_perp_mag * vectorScale, 0x64748b, 0.15, 0.08);
        
        const dir_axial = new THREE.Vector3(chargeSign > 0 ? 1 : -1, 0, 0);
        const dEx_vec = new THREE.ArrowHelper(dir_axial, P_pos, fields.dEx * vectorScale, 0xf59e0b, 0.15, 0.08);
        
        // --- Create new vectors for dq2 ---
        const dq2_pos = dqElement2.position;
        const dir2 = new THREE.Vector3().subVectors(P_pos, dq2_pos);
        if (chargeSign < 0) dir2.negate();
        dir2.normalize();
        
        const dE_vec2 = new THREE.ArrowHelper(dir2, P_pos, fields.dE_mag * vectorScale, chargeColor, 0.2, 0.1);
        const dir_perp2 = new THREE.Vector3(0, dir2.y, dir2.z).normalize();
        const dE_perp_vec2 = new THREE.ArrowHelper(dir_perp2, P_pos, dE_perp_mag * vectorScale, 0x64748b, 0.15, 0.08);

        vectorGroup.add(dE_vec, dE_perp_vec, dEx_vec, dE_vec2, dE_perp_vec2);

        // Update total E vector
        const E_dir = new THREE.Vector3(fields.E_total > 0 ? 1 : -1, 0, 0);
        E_total_vector.position.copy(P_pos);
        E_total_vector.setDirection(E_dir);
        E_total_vector.setLength(Math.abs(fields.E_total * vectorScale), 0.25, 0.12);

        // Update dashed lines
        line1.geometry.setFromPoints([dq1_pos, P_pos]);
        line1.computeLineDistances();
        line2.geometry.setFromPoints([dq2_pos, P_pos]);
        line2.computeLineDistances();
    }
    
    function updateDataPanel() {
        const fields = calculateFields();
        rValueEl.textContent = fields.r.toFixed(2);
        dEValueEl.textContent = fields.dE_mag.toExponential(2);
        dExValueEl.textContent = fields.dEx.toExponential(2);
        QValueEl.textContent = fields.Q.toExponential(2);
        EtotalValueEl.textContent = Math.abs(fields.E_total).toExponential(2);
    }

    function handleInputChange() {
        state.a = parseFloat(radiusSlider.value);
        state.x0 = parseFloat(x0Slider.value);
        state.lambda = parseFloat(densitySlider.value);
        state.dqAngle = parseFloat(dqAngleSlider.value) * Math.PI / 180;
        
        radiusValue.textContent = state.a.toFixed(1);
        x0Value.textContent = state.x0.toFixed(1);
        densityValue.textContent = state.lambda.toFixed(1);
        dqAngleValue.textContent = dqAngleSlider.value;

        updateDataPanel();
        updateScene();
        if (window.MathJax) MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }

    function resetSimulation() {
        state = { ...initialState };
        radiusSlider.value = state.a;
        x0Slider.value = state.x0;
        densitySlider.value = state.lambda;
        dqAngleSlider.value = state.dqAngle * 180 / Math.PI;
        chargeSignBtn.classList.toggle('bg-red-500', true);
        chargeSignBtn.classList.toggle('bg-blue-500', false);
        chargeSignBtn.textContent = 'Carga Positiva';
        handleInputChange();
    }
    
    function onMouseDown(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects([pointP]);

        if (intersects.length > 0) {
            draggedObject = pointP;
            controls.enabled = false;
            dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(dragPlane.normal).cross(new THREE.Vector3(1,0,0)), pointP.position);
        }
    }

    function onMouseMove(event) {
        if (draggedObject) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(dragPlane, intersectPoint);
            
            let newX0 = intersectPoint.x;
            state.x0 = Math.max(0, Math.min(parseFloat(x0Slider.max), newX0));
            x0Slider.value = state.x0.toFixed(1);
            handleInputChange();
        }
    }

    function onMouseUp(event) {
        draggedObject = null;
        controls.enabled = true;
    }

    [radiusSlider, x0Slider, densitySlider, dqAngleSlider].forEach(s => s.addEventListener('input', handleInputChange));
    resetBtn.addEventListener('click', resetSimulation);
    chargeSignBtn.addEventListener('click', () => {
        state.chargeSign *= -1;
        const isPositive = state.chargeSign > 0;
        chargeSignBtn.textContent = isPositive ? 'Carga Positiva' : 'Carga Negativa';
        chargeSignBtn.classList.toggle('bg-red-500', isPositive);
        chargeSignBtn.classList.toggle('bg-blue-500', !isPositive);
        handleInputChange();
    });

    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            tabContents.forEach(content => {
                content.id === button.dataset.tab ? content.classList.add('active') : content.classList.remove('active');
            });
            if (window.MathJax) MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
        });
    });

    document.getElementById('theme-toggle').addEventListener('change', () => {
        document.documentElement.classList.toggle('dark');
        updateScene();
    });

    init3D();
    resetSimulation();
    document.querySelector('[data-tab="controles"]').click();
});
</script>
</body>
</html>
