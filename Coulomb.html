<!DOCTYPE html>
<html lang="es">
<head>
    <!-- Google tag (gtag.js) --> <script async src="https://www.googletagmanager.com/gtag/js?id=G-EXGD1GSLLB"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-EXGD1GSLLB'); </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio Virtual: Ley de Coulomb IA</title>
    <meta name="description" content="Tutor inteligente con coordenadas editables y validaci√≥n robusta.">
    
    <!-- Librer√≠as -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            --bg-color: #1e1e2e;
            --panel-color: #2b2b3b;
            --accent-color: #4ecca3;
            --danger-color: #ff6b6b;
            --text-color: #e0e0e0;
            --border-color: #444;
            --force-color: #f1c40f;
            --selection-color: #00ff88;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            height: 100vh;
            display: flex; flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        header {
            background: #151520;
            padding: 10px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex; justify-content: space-between; align-items: center;
        }

        h2 { margin: 0; color: var(--accent-color); font-size: 1.2rem; }
        .version { font-size: 0.8rem; color: #666; }

        .workspace {
            display: grid;
            grid-template-columns: 260px 1fr 380px; 
            height: calc(100vh - 50px);
        }

        .panel {
            background: var(--panel-color);
            border-right: 1px solid var(--border-color);
            display: flex; flex-direction: column;
            padding: 15px; gap: 15px;
            overflow-y: auto;
        }
        .panel-right { border-right: none; border-left: 1px solid var(--border-color); }

        .section-title {
            font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1px;
            color: #888; margin-bottom: 8px; font-weight: bold;
        }

        .toolbar { display: flex; flex-direction: column; gap: 8px; }
        
        .btn-tool {
            padding: 10px 12px;
            border: 1px solid transparent; border-radius: 6px;
            background: #3a3a4a; color: white;
            cursor: pointer; text-align: left; transition: all 0.2s;
            display: flex; align-items: center; gap: 10px; font-size: 0.9rem;
        }
        .btn-tool:hover { background: #4a4a5a; border-color: #666; }
        .btn-tool.active { background: var(--accent-color); color: #1e1e2e; font-weight: bold; }
        
        .btn-action { background: var(--accent-color); color: #1e1e2e; font-weight: bold; justify-content: center; }
        .btn-danger { background: rgba(255, 107, 107, 0.1); color: var(--danger-color); border: 1px solid var(--danger-color); }
        .btn-danger:hover { background: var(--danger-color); color: white; }

        .data-card {
            background: #1a1a24; padding: 10px; border-radius: 6px;
            border-left: 3px solid #666; margin-bottom: 8px;
            transition: 0.2s;
        }
        .data-card.selected { border-left-color: var(--selection-color); background: #252a28; }
        
        .data-header { display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 5px; color: #ccc; }
        .input-row { display: flex; gap: 5px; align-items: center; margin-top: 5px; }
        
        /* Inputs mejorados */
        input[type="number"], select {
            background: #2b2b3b; border: 1px solid #555; color: white;
            padding: 4px; border-radius: 4px; width: 100%; font-size: 0.85rem;
        }
        input[type="number"]:focus { border-color: var(--accent-color); outline: none; }

        .canvas-area {
            position: relative; background-color: #ffffff;
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden; display: flex; justify-content: center; align-items: center;
        }
        canvas { cursor: crosshair; touch-action: none; z-index: 1; }
        
        #labels-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 2; overflow: hidden;
        }
        .canvas-label {
            position: absolute; background: rgba(255, 255, 255, 0.95);
            padding: 2px 6px; border-radius: 4px; border: 1px solid #3498db;
            font-size: 0.9rem; color: #222; transform: translate(-50%, -100%); 
            box-shadow: 0 2px 5px rgba(0,0,0,0.15); white-space: nowrap;
        }

        #coords-indicator {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(0,0,0,0.8); color: #4ecca3;
            padding: 4px 8px; border-radius: 4px; font-size: 0.75rem;
            pointer-events: none; z-index: 3; font-family: monospace;
        }
        
        .feedback-card {
            background: #1a1a24; padding: 12px; border-radius: 8px;
            border-left: 4px solid var(--force-color); margin-bottom: 10px; font-size: 0.9rem;
        }
        .result-item { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #333; font-size: 0.9rem; }
        .result-correct { color: var(--accent-color); }
        .result-error { color: var(--danger-color); }
        .result-warn { color: #f39c12; }

        .badge { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.75rem; margin: 2px; }
        .badge-pos { background: #3498db; color: white; }
        .badge-neg { background: #e74c3c; color: white; }
        
        .latex-box {
            background: white; color: black; padding: 10px; border-radius: 6px;
            min-height: 100px; font-size: 0.85rem; overflow-x: auto;
            display: flex; flex-direction: column; text-align: left;
        }

        /* Bot√≥n Flotante Eliminar */
        #float-delete {
            position: absolute; display: none;
            background: #ff6b6b; color: white; border: none;
            padding: 5px 10px; border-radius: 4px; cursor: pointer;
            font-size: 0.8rem; z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #float-delete:hover { background: #ff4444; }

        /* Modal */
        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 2000;
            justify-content: center; align-items: center;
        }
        .modal-content {
            background: white; padding: 20px; border-radius: 10px; width: 450px;
            text-align: center; position: relative; color: #222;
        }
        .close-btn { position: absolute; top: 10px; right: 15px; font-size: 24px; cursor: pointer; }
    </style>
</head>
<body>

<header>
    <div><h2>‚ö° Laboratorio Coulomb IA</h2></div>
    <div class="version">v3.5.0 (Paso a Paso Detallado)</div>
</header>

<div class="workspace">
    <div class="panel">
        <div>
            <div class="section-title">Herramientas</div>
            <div class="toolbar">
                <button class="btn-tool active" onclick="setTool('draw', this)">‚úèÔ∏è L√°piz (Dibujar)</button>
                <button class="btn-tool" onclick="setTool('move', this)">‚úã Mover / Editar</button>
                <button class="btn-tool" onclick="undo()">‚Ü©Ô∏è Deshacer Trazos</button>
                <button class="btn-tool btn-danger" onclick="limpiarTodo()">üóëÔ∏è Limpiar Todo</button>
            </div>
        </div>
        <hr style="border:0; border-top:1px solid var(--border-color); margin: 5px 0;">
        <div>
            <div class="section-title">Datos</div>
            <div style="margin-bottom: 10px;">
                <label style="font-size:0.8rem; color:#aaa;">Distancia:</label>
                <select id="dist-unit" onchange="analizarFisica()">
                    <option value="1">Metros (m)</option>
                    <option value="0.01">Cent√≠metros (cm)</option>
                </select>
            </div>
            <div style="margin-bottom: 10px;">
                <label style="font-size:0.8rem; color:#aaa;">Escala:</label>
                <div style="display:flex; gap:5px; align-items:center;">
                    <input type="number" id="scale-input" value="100" style="width:70px" onchange="analizarFisica()">
                    <span style="font-size:0.7rem; color:#888;">px = 1 unidad</span>
                </div>
            </div>
            <div id="charges-container"></div>
        </div>
        <!-- Bot√≥n para forzar verificaci√≥n -->
        <button class="btn-tool btn-action" style="margin-top:15px;" onclick="analizarFisica()">üîç VERIFICAR / CALCULAR</button>
    </div>

    <div class="canvas-area" id="canvas-wrapper">
        <canvas id="main-canvas"></canvas>
        <button id="float-delete" onclick="deleteSelected()">üóëÔ∏è Eliminar</button>
        <div id="labels-overlay"></div>
        <div id="coords-indicator">x: 0, y: 0</div>
    </div>

    <div class="panel panel-right">
        <div>
            <div class="section-title">Objetos Detectados</div>
            <div class="feedback-card" style="border-left-color: #3498db;">
                <div id="detection-list"><i>Esperando...</i></div>
            </div>
        </div>
        <div>
            <div class="section-title">Validaci√≥n</div>
            <div class="feedback-card" id="validation-box">...</div>
        </div>
        <div>
            <div class="section-title">Soluci√≥n Paso a Paso</div>
            <div id="dcl-buttons" style="display:flex; flex-wrap:wrap; gap:5px; margin-bottom:10px;"></div>
            <div class="latex-box" id="latex-result">$$ \text{---} $$</div>
        </div>
    </div>
</div>

<div class="modal" id="fbd-modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal()">&times;</span>
        <h3 id="fbd-title" style="margin-top:0;">Diagrama Cuerpo Libre</h3>
        <canvas id="fbd-canvas" width="400" height="400"></canvas>
    </div>
</div>

<script>
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('canvas-wrapper');
    const labelsOverlay = document.getElementById('labels-overlay');
    const floatDelete = document.getElementById('float-delete');
    
    // Estado Global
    let state = {
        tool: 'draw',
        isDrawing: false,
        isDragging: false,
        draggedObject: null,
        selectedObject: null,
        recognitionTimer: null, 
        rawStrokes: [],      
        currentStroke: [],   
        objects: [],         
        calculatedForces: [] 
    };

    // Configuraci√≥n Canvas
    ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = 3;

    function resizeCanvas() {
        canvas.width = wrapper.clientWidth; canvas.height = wrapper.clientHeight;
        redraw();
    }
    window.addEventListener('resize', resizeCanvas);
    setTimeout(resizeCanvas, 100);

    // Helpers de Coordenadas
    function toPhysY(cy) { return canvas.height - cy; }
    function toCanvasY(py) { return canvas.height - py; }
    function getCoords(e) {
        const r = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - r.left, y: clientY - r.top };
    }

    // --- Manejadores de Eventos ---
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('touchstart', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('touchmove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchend', handleEnd);

    function handleStart(e) {
        if (e.touches) e.preventDefault(); 
        const c = getCoords(e);
        
        if (state.tool === 'move') {
            const hit = findObjectAt(c);
            if (hit) {
                state.isDragging = true;
                state.draggedObject = hit;
                selectObject(hit);
            } else {
                selectObject(null);
            }
            return;
        }

        if (state.recognitionTimer) {
            clearTimeout(state.recognitionTimer);
            state.recognitionTimer = null;
        }
        
        state.isDrawing = true;
        state.currentStroke = [c];
    }

    function handleMove(e) {
        if (e.touches) e.preventDefault();
        const c = getCoords(e);
        document.getElementById('coords-indicator').innerText = `x: ${Math.round(c.x)}, y: ${Math.round(toPhysY(c.y))}`;

        if (state.isDragging && state.draggedObject) {
            if (state.draggedObject.type.startsWith('charge')) {
                state.draggedObject.x = c.x;
                state.draggedObject.y = c.y;
                state.draggedObject.physX = c.x;
                state.draggedObject.physY = toPhysY(c.y);
            } else if (state.draggedObject.type === 'vector') {
                const w = state.draggedObject.end.x - state.draggedObject.start.x;
                const h = state.draggedObject.end.y - state.draggedObject.start.y;
                state.draggedObject.start = {x: c.x, y: c.y};
                state.draggedObject.end = {x: c.x + w, y: c.y + h};
            }
            updateFloatDelete();
            // No actualizamos UI completa en cada frame para rendimiento, solo al soltar
            redraw();
        } 
        else if (state.isDrawing) {
            state.currentStroke.push(c);
            redraw();
        }
    }

    function handleEnd(e) {
        if (state.isDragging) {
            state.isDragging = false;
            state.draggedObject = null;
            updateUI(); // Sincronizar inputs al soltar
            analizarFisica(); 
            return;
        }

        if (state.isDrawing) {
            state.isDrawing = false;
            if (state.currentStroke.length > 3) {
                state.rawStrokes.push([...state.currentStroke]);
            }
            state.currentStroke = [];
            
            state.recognitionTimer = setTimeout(() => {
                detectAndConvert();
                state.recognitionTimer = null;
            }, 1200); 
            
            redraw();
        }
    }

    function findObjectAt(c) {
        const charge = state.objects.find(o => o.type.startsWith('charge') && Math.hypot(o.x - c.x, o.y - c.y) < 30);
        if (charge) return charge;
        const vec = state.objects.find(o => o.type === 'vector' && (
            Math.hypot(o.start.x - c.x, o.start.y - c.y) < 25 || 
            Math.hypot(o.end.x - c.x, o.end.y - c.y) < 25
        ));
        return vec;
    }

    function selectObject(obj) {
        state.selectedObject = obj;
        document.querySelectorAll('.data-card').forEach(card => card.classList.remove('selected'));
        if (obj) {
            updateFloatDelete();
            floatDelete.style.display = 'block';
            if (obj.type.startsWith('charge')) {
                const input = document.getElementById(`q-${obj.id}`);
                if(input) {
                    const card = input.closest('.data-card');
                    if(card) card.classList.add('selected');
                }
            }
        } else {
            floatDelete.style.display = 'none';
        }
        redraw();
    }

    function updateFloatDelete() {
        if(!state.selectedObject) return;
        const o = state.selectedObject;
        let bx, by;
        if(o.type.startsWith('charge')) { bx = o.x; by = o.y - 35; }
        else { bx = (o.start.x+o.end.x)/2; by = (o.start.y+o.end.y)/2 - 20; }
        floatDelete.style.left = (bx - 30) + 'px'; 
        floatDelete.style.top = by + 'px';
    }

    function deleteSelected() {
        if (state.selectedObject) {
            state.objects = state.objects.filter(o => o !== state.selectedObject);
            selectObject(null);
            updateUI();
            analizarFisica();
            redraw();
        }
    }

    // --- L√≥gica de Detecci√≥n (Ink-to-Shape) ---
    function detectAndConvert() {
        const groups = groupStrokes(state.rawStrokes);
        const newObjects = [];
        const usedIndices = new Set();

        groups.forEach(group => {
            const bounds = getGroupBounds(group);
            const type = classifyGroup(group, bounds);
            
            if (type !== 'unknown') {
                if (type.startsWith('charge')) {
                    const id = state.objects.filter(o => o.type.startsWith('charge')).length + 1;
                    newObjects.push({
                        id: id, type: type, label: `q_${id}`,
                        x: bounds.cx, y: bounds.cy, physX: bounds.cx, physY: toPhysY(bounds.cy),
                        q: type === 'charge_pos' ? 5 : -5
                    });
                } else if (type === 'vector') {
                    const eps = getVectorEndpoints(group);
                    newObjects.push({
                        type: 'vector', start: eps.start, end: eps.end,
                        validation: null, label: '?'
                    });
                }
                group.forEach(i => usedIndices.add(i));
            }
        });

        if (newObjects.length > 0) {
            state.rawStrokes = state.rawStrokes.filter((_, i) => !usedIndices.has(i));
            state.objects.push(...newObjects);
            updateUI();
            analizarFisica();
        }
        redraw();
    }

    function getGroupBounds(indices) {
        let allPts = [];
        indices.forEach(i => {
            if(state.rawStrokes[i]) state.rawStrokes[i].forEach(p => allPts.push(p));
        });
        if(allPts.length === 0) return { minX:0, maxX:0, minY:0, maxY:0, w:0, h:0, cx:0, cy:0 };
        return getBounds(allPts);
    }

    function groupStrokes(strokes) {
        const groups = []; const visited = new Set();
        for(let i=0; i<strokes.length; i++) {
            if(visited.has(i)) continue;
            const g = [i]; visited.add(i);
            for(let j=i+1; j<strokes.length; j++) {
                if(visited.has(j)) continue;
                if(strokesClose(strokes[i], strokes[j])) { g.push(j); visited.add(j); }
            }
            groups.push(g);
        }
        return groups;
    }
    
    function strokesClose(s1, s2) {
        const b1 = getBounds(s1); const b2 = getBounds(s2);
        const pad = 30; 
        return !(b2.minX > b1.maxX + pad || b2.maxX < b1.minX - pad || b2.minY > b1.maxY + pad || b2.maxY < b1.minY - pad);
    }
    
    function classifyGroup(indices, b) {
        const strokes = indices.map(i => state.rawStrokes[i]);
        let totalLen = 0; 
        strokes.forEach(s => { 
            for(let k=0; k<s.length-1; k++) totalLen += Math.hypot(s[k+1].x-s[k].x, s[k+1].y-s[k].y); 
        });
        
        const r = b.w/b.h;
        const isCompact = r > 0.5 && r < 2.0 && b.w > 20 && b.h > 20;

        if (isCompact) {
            let maxL = 0; let boundaryIdx = -1;
            strokes.forEach((s, i) => {
                let l = 0;
                for(let k=0; k<s.length-1; k++) l += Math.hypot(s[k+1].x-s[k].x, s[k+1].y-s[k].y);
                if (l > maxL) { maxL = l; boundaryIdx = i; }
            });

            const boundary = strokes[boundaryIdx];
            const distEnds = Math.hypot(boundary[0].x - boundary[boundary.length-1].x, boundary[0].y - boundary[boundary.length-1].y);
            const isClosed = distEnds < maxL * 0.4; 

            if (isClosed) {
                const innerStrokes = strokes.filter((_, i) => i !== boundaryIdx);
                if (innerStrokes.length === 0) return 'charge_pos';
                if (innerStrokes.length === 1) {
                    const inner = innerStrokes[0];
                    const ib = getBounds(inner);
                    if (ib.w > ib.h * 1.5) return 'charge_neg';
                    return 'charge_pos';
                }
                return 'charge_pos';
            }
        }
        
        const diag = Math.hypot(b.w, b.h);
        if (diag > 30) return 'vector';
        
        return 'unknown';
    }

    function getVectorEndpoints(indices) {
        let maxL = 0; let main = null;
        const strokes = indices.map(i => state.rawStrokes[i]);
        strokes.forEach(s => {
            const l = Math.hypot(s[0].x - s[s.length-1].x, s[0].y - s[s.length-1].y);
            if(l > maxL) { maxL = l; main = s; }
        });
        if(!main) return { start:{x:0,y:0}, end:{x:0,y:0} };
        
        const p1 = main[0]; const p2 = main[main.length-1];
        let d1 = 0; let d2 = 0;
        strokes.forEach(s => {
            if(s===main) return;
            s.forEach(p => {
                if(Math.hypot(p.x-p1.x, p.y-p1.y) < 30) d1++;
                if(Math.hypot(p.x-p2.x, p.y-p2.y) < 30) d2++;
            });
        });
        if (d1 > d2) return { start: p2, end: p1 };
        return { start: p1, end: p2 };
    }

    // --- F√≠sica ---
    function analizarFisica() {
        const charges = state.objects.filter(o => o.type.startsWith('charge'));
        const vectors = state.objects.filter(o => o.type === 'vector');
        const Ke = 8.987e9;
        const scale = parseFloat(document.getElementById('scale-input').value || 100);
        const distU = parseFloat(document.getElementById('dist-unit').value || 1);
        
        // Sincronizar Q desde inputs si es necesario, pero ahora X e Y tambi√©n se manejan via updateCoord
        charges.forEach(c => {
            const elQ = document.getElementById(`q-${c.id}`);
            if(elQ) c.q = parseFloat(elQ.value);
        });

        const interactions = [];
        charges.forEach(tgt => {
            charges.forEach(src => {
                if(tgt.id === src.id) return;
                const dx = src.physX - tgt.physX; const dy = src.physY - tgt.physY;
                let ang = Math.atan2(dy, dx);
                if(tgt.q * src.q > 0) ang += Math.PI;
                ang = (ang + 4*Math.PI) % (2*Math.PI);
                const r = Math.hypot(dx, dy) / scale * distU;
                const mag = r>0 ? (Ke * Math.abs(tgt.q*src.q)*1e-12)/(r*r) : 0;
                interactions.push({ t: tgt, s: src, ang, mag, lbl: `F_{${src.id}${tgt.id}}` });
            });
        });

        state.calculatedForces = [];
        const vBox = document.getElementById('validation-box'); vBox.innerHTML='';
        
        if(vectors.length === 0) {
            vBox.innerHTML = '<i>Dibuja flechas de fuerza sobre las cargas.</i>';
        }

        vectors.forEach(vec => {
            const origin = charges.find(c => Math.hypot(c.x - vec.start.x, c.y - vec.start.y) < 60);
            
            if(!origin) { 
                vec.validation='warn'; vec.label='?'; 
                vBox.innerHTML += `<div class="result-item result-warn">‚ö†Ô∏è Vector suelto</div>`;
                return; 
            }
            
            const vAng = (Math.atan2(toPhysY(vec.end.y) - toPhysY(vec.start.y), vec.end.x - vec.start.x) + 4*Math.PI)%(2*Math.PI);
            
            let best = null; let minD = 100;
            const cands = interactions.filter(i => i.t.id === origin.id);
            cands.forEach(cand => {
                let d = Math.abs(cand.ang - vAng);
                if(d > Math.PI) d = 2*Math.PI - d;
                if(d < minD) { minD = d; best = cand; }
            });

            if(best && minD < 0.6) {
                vec.validation = 'correct'; vec.label = best.lbl;
                vBox.innerHTML += `<div class="result-item result-correct">‚úÖ ${best.lbl} Correcta en ${origin.label}</div>`;
                state.calculatedForces.push({
                    target: origin.id, source: best.s.id, label: best.lbl,
                    mag: best.mag, angleDeg: (best.ang*180/Math.PI)%360,
                    Fx: best.mag*Math.cos(best.ang), Fy: best.mag*Math.sin(best.ang)
                });
            } else {
                vec.validation = 'error'; vec.label = '?';
                vBox.innerHTML += `<div class="result-item result-error">‚ùå Direcci√≥n Errada en ${origin.label}</div>`;
            }
        });
        
        renderLatex();
        setupDCLButtons();
        redraw();
    }

    // --- Funciones UI Actualizadas para Edici√≥n ---
    function updateCoord(id, axis, val) {
        const obj = state.objects.find(o => o.id === id);
        if(!obj) return;
        
        const numVal = parseFloat(val);
        if(isNaN(numVal)) return;

        if (axis === 'x') {
            obj.physX = numVal;
            obj.x = numVal; // En canvas X = Phys X (solo offset si hubiera pan/zoom)
        } else {
            obj.physY = numVal;
            obj.y = toCanvasY(numVal);
        }
        
        analizarFisica();
        redraw();
    }

    function updateUI() {
        const c = document.getElementById('charges-container'); c.innerHTML='';
        state.objects.filter(o=>o.type.startsWith('charge')).forEach(ch => {
            const div = document.createElement('div'); div.className='data-card';
            if(state.selectedObject === ch) div.classList.add('selected');
            
            // Generar inputs para X e Y
            div.innerHTML = `
                <div class="data-header"><strong>${ch.label}</strong></div>
                <div class="input-row">
                    <label>Q</label>
                    <input type="number" id="q-${ch.id}" value="${ch.q}" onchange="analizarFisica()">
                </div>
                <div class="input-row">
                    <label>X</label>
                    <input type="number" value="${Math.round(ch.physX)}" onchange="updateCoord(${ch.id}, 'x', this.value)">
                    <label>Y</label>
                    <input type="number" value="${Math.round(ch.physY)}" onchange="updateCoord(${ch.id}, 'y', this.value)">
                </div>`;
            c.appendChild(div);
        });
        document.getElementById('detection-list').innerHTML = state.objects.map(o=>
            o.type==='vector'?'<span class="badge badge-vec">Vec</span>':`<span class="badge ${o.type==='charge_pos'?'badge-pos':'badge-neg'}">${o.label}</span>`
        ).join('');
    }
    
    // --- Helpers Gen√©ricos ---
    function setTool(t, b) {
        state.tool = t;
        document.querySelectorAll('.btn-tool').forEach(el=>el.classList.remove('active'));
        if(b) b.classList.add('active');
        if(t==='draw') selectObject(null);
    }
    function undo() { 
        if(state.rawStrokes.length>0) state.rawStrokes.pop(); 
        else if(state.objects.length>0) { state.objects.pop(); updateUI(); analizarFisica(); }
        redraw(); 
    }
    function limpiarTodo() { state.objects=[]; state.rawStrokes=[]; updateUI(); analizarFisica(); redraw(); document.getElementById('latex-result').innerText='---'; }

    // --- Renderizado ---
    function redraw() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        labelsOverlay.innerHTML = '';
        
        ctx.strokeStyle = '#eee'; ctx.lineWidth=1; ctx.beginPath();
        for(let i=0; i<canvas.width; i+=20) { ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); }
        for(let i=0; i<canvas.height; i+=20) { ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); }
        ctx.stroke();

        ctx.strokeStyle = '#999'; ctx.lineWidth=2;
        state.rawStrokes.forEach(s => drawPath(s));
        if(state.currentStroke.length>0) drawPath(state.currentStroke);

        state.objects.forEach(obj => {
            const isSel = (state.selectedObject === obj);
            ctx.shadowBlur = isSel ? 10 : 0; ctx.shadowColor = '#00ff88';

            if(obj.type.startsWith('charge')) {
                ctx.beginPath(); ctx.arc(obj.x, obj.y, 20, 0, Math.PI*2);
                ctx.fillStyle = obj.type==='charge_pos' ? '#3498db' : '#e74c3c';
                ctx.fill(); ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.stroke();
                ctx.shadowBlur=0;
                ctx.fillStyle='white'; ctx.font='bold 24px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText(obj.type==='charge_pos'?'+':'-', obj.x, obj.y+2);
                addLabel(obj.x+25, obj.y-25, obj.label);
            } 
            else if(obj.type === 'vector') {
                const col = obj.validation==='correct'?'#4ecca3':obj.validation==='error'?'#ff6b6b':'#f1c40f';
                ctx.strokeStyle = col; ctx.fillStyle = col; ctx.lineWidth = isSel ? 5 : 3;
                drawArrow(obj.start.x, obj.start.y, obj.end.x, obj.end.y);
                ctx.shadowBlur=0;
                if(obj.label) addLabel(obj.end.x, obj.end.y-15, obj.label);
            }
        });
    }

    function drawPath(pts) {
        if(pts.length<2) return;
        ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.stroke();
    }
    
    function drawArrow(x1, y1, x2, y2) {
        const head = 15; const ang = Math.atan2(y2-y1, x2-x1);
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x2,y2);
        ctx.lineTo(x2-head*Math.cos(ang-Math.PI/6), y2-head*Math.sin(ang-Math.PI/6));
        ctx.lineTo(x2-head*Math.cos(ang+Math.PI/6), y2-head*Math.sin(ang+Math.PI/6));
        ctx.fill();
    }

    function addLabel(x, y, t) {
        const d = document.createElement('div'); d.className='canvas-label';
        d.style.left=x+'px'; d.style.top=y+'px';
        katex.render(t, d, {throwOnError:false});
        labelsOverlay.appendChild(d);
    }
    function getBounds(pts) {
        const xs = pts.map(p=>p.x); const ys = pts.map(p=>p.y);
        return { minX:Math.min(...xs), maxX:Math.max(...xs), minY:Math.min(...ys), maxY:Math.max(...ys), w:Math.max(...xs)-Math.min(...xs), h:Math.max(...ys)-Math.min(...ys), cx:(Math.min(...xs)+Math.max(...xs))/2, cy:(Math.min(...ys)+Math.max(...ys))/2 };
    }
    
    // --- LaTeX ---
    function renderLatex() {
        const box = document.getElementById('latex-result');
        let html = "";
        const groups = {}; state.calculatedForces.forEach(f=>{ if(!groups[f.target]) groups[f.target]=[]; groups[f.target].push(f); });
        
        if(Object.keys(groups).length===0) html="\\text{Sin fuerzas correctas}";
        else {
            for(const [tid, fs] of Object.entries(groups)) {
                html += `\\underline{\\text{Carga } q_${tid}}:\\\\`;
                let sx=0, sy=0;
                
                html += `\\text{1. Componentes:} \\\\ \\begin{aligned}`;
                fs.forEach(f=>{ 
                    // Muestra las componentes individuales con c√°lculo
                    html += `${f.label} &= ${f.mag.toExponential(2)} \\text{ N} \\quad (\\theta=${f.angleDeg.toFixed(1)}^\\circ) \\\\`;
                    html += `{${f.label}}_x &= ${f.mag.toExponential(2)} \\cos(${f.angleDeg.toFixed(1)}^\\circ) = ${f.Fx.toExponential(2)} \\text{ N} \\\\`;
                    html += `{${f.label}}_y &= ${f.mag.toExponential(2)} \\sin(${f.angleDeg.toFixed(1)}^\\circ) = ${f.Fy.toExponential(2)} \\text{ N} \\\\[0.5em]`;
                    sx += f.Fx; sy += f.Fy; 
                });
                html += `\\end{aligned} \\\\[1em]`;

                // Sumatoria y Resultante
                const R = Math.hypot(sx, sy);
                const Rang = (Math.atan2(sy, sx) * 180 / Math.PI + 360) % 360;

                html += `\\text{2. Resultante:} \\\\ \\begin{aligned}`;
                html += `\\sum F_x &= \\mathbf{${sx.toExponential(2)} \\text{ N}} \\\\`;
                html += `\\sum F_y &= \\mathbf{${sy.toExponential(2)} \\text{ N}} \\\\`;
                html += `|\\vec{F}_R| &= \\sqrt{(${sx.toExponential(2)})^2 + (${sy.toExponential(2)})^2} = \\mathbf{${R.toExponential(2)} \\text{ N}} \\\\`;
                html += `\\theta_R &= \\tan^{-1}\\left(\\frac{${sy.toExponential(2)}}{${sx.toExponential(2)}}\\right) = \\mathbf{${Rang.toFixed(1)}^\\circ}`;
                html += `\\end{aligned} \\\\[2em]`;
            }
        }
        katex.render(html, box, {displayMode:true, throwOnError:false});
    }

    // --- Modal DCL ---
    function setupDCLButtons() {
        const d=document.getElementById('dcl-buttons'); d.innerHTML='';
        const t = new Set(state.calculatedForces.map(f=>f.target));
        t.forEach(tid=>{
            const b=document.createElement('button'); b.className='btn-tool'; b.style.padding='4px';
            b.innerText=`DCL q${tid}`; b.onclick=()=>openDCL(tid); d.appendChild(b);
        });
    }
    function openDCL(id) {
        document.getElementById('fbd-modal').style.display='flex';
        const cx=document.getElementById('fbd-canvas').getContext('2d');
        const fs = state.calculatedForces.filter(f=>f.target==id);
        const ch = state.objects.find(o=>o.id==id);
        cx.clearRect(0,0,400,400);
        cx.strokeStyle='#ccc'; cx.beginPath(); cx.moveTo(200,0); cx.lineTo(200,400); cx.moveTo(0,200); cx.lineTo(400,200); cx.stroke();
        cx.beginPath(); cx.arc(200,200,15,0,2*Math.PI); cx.fillStyle=ch.type==='charge_pos'?'#3498db':'#e74c3c'; cx.fill();
        const max = Math.max(...fs.map(f=>f.mag), 1e-9); const s = 140/max;
        fs.forEach(f=>{ 
            const dx=f.Fx*s; const dy=-f.Fy*s; // Fy phys up -> Canvas down
            const col='#f1c40f';
            cx.strokeStyle=col; cx.fillStyle=col; cx.lineWidth=3;
            const x2=200+dx, y2=200+dy;
            cx.beginPath(); cx.moveTo(200,200); cx.lineTo(x2,y2); cx.stroke();
            const ang=Math.atan2(y2-200, x2-200);
            cx.beginPath(); cx.moveTo(x2,y2); 
            cx.lineTo(x2-10*Math.cos(ang-Math.PI/6), y2-10*Math.sin(ang-Math.PI/6));
            cx.lineTo(x2-10*Math.cos(ang+Math.PI/6), y2-10*Math.sin(ang+Math.PI/6)); cx.fill();
            cx.fillStyle='black'; cx.fillText(f.label.replace(/[{}_]/g,''), x2+10, y2);
        });
    }
    function closeModal() { document.getElementById('fbd-modal').style.display='none'; }
</script>
</body>

</html>
