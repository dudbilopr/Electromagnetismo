<!DOCTYPE html>
<html lang="es" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Campo Eléctrico: Anillo Semicircular</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-light: #f8fafc; /* slate-50 */
            --bg-dark: #0f172a;  /* slate-900 */
            --text-light: #1e2b3b; /* slate-800 */
            --text-dark: #e2e8f0; /* slate-200 */
            --border-light: #e2e8f0; /* slate-200 */
            --border-dark: #334155; /* slate-700 */
            --panel-light: #ffffff;
            --panel-dark: #1e2b3b; /* slate-800 */
            --accent-color: #3b82f6; /* blue-500 */
            --tab-inactive-light: #f1f5f9; /* slate-100 */
            --tab-inactive-dark: #334155; /* slate-700 */
        }
        html.dark {
            --bg-light: #0f172a;
            --text-light: #e2e8f0;
            --border-light: #334155;
            --panel-light: #1e2b3b;
            --tab-inactive-light: #334155;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-light);
            color: var(--text-light);
            transition: background-color 0.3s, color 0.3s;
        }
        .panel {
            background-color: var(--panel-light);
            border: 1px solid var(--border-light);
            transition: background-color 0.3s, border-color 0.3s;
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-button {
            background-color: var(--tab-inactive-light);
            color: var(--text-light);
        }
        .tab-button.active {
            background-color: var(--accent-color);
            color: white;
        }
        html.dark .tab-button { color: var(--text-dark); }
        html.dark .tab-button.active { color: white; }

        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            background: transparent; cursor: pointer; width: 100%;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 0.5rem; border-radius: 0.25rem; background: var(--border-light);
        }
        input[type="range"]::-moz-range-track {
            height: 0.5rem; border-radius: 0.25rem; background: var(--border-light);
        }
        input[type="range"]::-webkit-slider-thumb {
           -webkit-appearance: none; appearance: none;
            margin-top: -0.25rem; width: 1rem; height: 1rem;
            border-radius: 9999px; background-color: var(--accent-color);
        }
        input[type="range"]::-moz-range-thumb {
            width: 1rem; height: 1rem; border-radius: 9999px;
            background-color: var(--accent-color); border: none;
        }
        .canvas-container {
            aspect-ratio: 1 / 1;
            max-width: 80vh; max-height: 80vh;
            margin: auto;
        }
        @media (min-width: 1024px) {
            .canvas-container { max-width: none; max-height: none; }
        }
    </style>
</head>
<body class="min-h-screen p-4">

<div class="w-full max-w-screen-2xl mx-auto flex flex-col lg:flex-row gap-4">
    <!-- Main Simulation Area -->
    <main class="flex-grow flex flex-col items-center justify-center panel rounded-xl shadow-lg p-4">
        <h1 class="text-2xl font-bold text-center mb-4 text-blue-600 dark:text-blue-400">Campo Eléctrico de un Arco Anular</h1>
        <div id="canvas-parent" class="w-full h-full canvas-container">
            <canvas id="simulationCanvas"></canvas>
        </div>
    </main>

    <!-- Control and Information Panel -->
    <aside class="w-full lg:w-[500px] flex-shrink-0">
        <div class="panel rounded-xl shadow-lg p-4">
            <div class="mb-4 text-center">
                <p class="text-sm text-slate-600 dark:text-slate-400">
                    Ajusta los parámetros y arrastra el anillo diferencial ($da$) para entender la integración.
                </p>
            </div>

            <!-- Tab Navigation -->
            <nav class="flex space-x-1 rounded-lg bg-slate-100 dark:bg-slate-900 p-1 mb-4">
                <button data-tab="controles" class="tab-button w-full text-sm font-semibold p-2 rounded-md transition-colors">Controles</button>
                <button data-tab="datos" class="tab-button w-full text-sm font-semibold p-2 rounded-md transition-colors">Datos</button>
                <button data-tab="teoria" class="tab-button w-full text-sm font-semibold p-2 rounded-md transition-colors">Teoría</button>
                <button data-tab="analisis" class="tab-button w-full text-sm font-semibold p-2 rounded-md transition-colors">Análisis</button>
            </nav>

            <!-- Tab Content -->
            <div>
                <!-- Controles Tab -->
                <div id="controles" class="tab-content">
                    <div class="my-3">
                        <label for="r1Slider" class="block text-sm font-medium">Radio Interno ($r_1$): <span id="r1Value">1.0</span> m</label>
                        <input id="r1Slider" type="range" min="0.5" max="3.5" value="1" step="0.1" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                     <div class="my-3">
                        <label for="r2Slider" class="block text-sm font-medium">Radio Externo ($r_2$): <span id="r2Value">2.5</span> m</label>
                        <input id="r2Slider" type="range" min="0.6" max="4" value="2.5" step="0.1" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="my-3">
                        <label for="angleSlider" class="block text-sm font-medium">Apertura del arco ($\alpha$): <span id="angleValue">180</span>°</label>
                        <input id="angleSlider" type="range" min="10" max="360" value="180" step="1" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="my-3">
                        <label for="densitySlider" class="block text-sm font-medium">Densidad superficial ($\sigma$): <span id="densityValue">5.0</span> nC/m²</label>
                        <input id="densitySlider" type="range" min="1" max="10" value="5" step="0.1" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="my-3">
                        <label for="vectorScaleSlider" class="block text-sm font-medium">Escala de Vectores: <span id="vectorScaleValue">1.0</span>x</label>
                        <input id="vectorScaleSlider" type="range" min="0.1" max="5" value="1" step="0.1" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                     <div class="grid grid-cols-2 gap-2 mt-4">
                        <button id="chargeSignBtn" class="p-2 rounded-lg font-semibold bg-red-500 text-white transition-colors">Carga Positiva</button>
                        <button id="resetBtn" class="p-2 rounded-lg font-semibold bg-gray-500 hover:bg-gray-600 text-white transition-colors">Reiniciar</button>
                    </div>
                    <div class="mt-4 flex items-center justify-center">
                        <span class="mr-2 text-sm font-medium">Claro</span>
                        <label for="theme-toggle" class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" value="" id="theme-toggle" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                        </label>
                        <span class="ml-2 text-sm font-medium">Oscuro</span>
                    </div>
                </div>

                <!-- Datos Tab -->
                <div id="datos" class="tab-content p-2 text-sm">
                    <p class="font-semibold text-base mb-2">Anillo Diferencial (en radio $a$)</p>
                    <div class="space-y-2 pl-2">
                        <p>Radio $a$: <span id="aValue" class="font-mono font-semibold text-blue-600 dark:text-blue-400">...</span> m</p>
                        <p>Carga $dq$: <span id="dqValue" class="font-mono font-semibold text-blue-600 dark:text-blue-400">...</span> C</p>
                        <p>Campo $|d\vec{E}|$: <span id="dEValue" class="font-mono font-semibold text-blue-600 dark:text-blue-400">...</span> N/C</p>
                    </div>
                    <hr class="my-4 border-slate-200 dark:border-slate-700">
                    <p class="font-semibold text-base mb-2">Campo Total (Integrado de $r_1$ a $r_2$)</p>
                     <div class="space-y-2 pl-2">
                        <p>Carga Total $Q$: <span id="QValue" class="font-mono font-semibold text-purple-600 dark:text-purple-400">...</span> C</p>
                        <p>Campo $|\vec{E}_{total}|$: <span id="EtotalValue" class="font-mono font-semibold text-purple-600 dark:text-purple-400">...</span> N/C</p>
                    </div>
                </div>
                
                <!-- Teoría Tab -->
                <div id="teoria" class="tab-content p-2 text-sm space-y-3">
                    <p class="font-semibold text-base">1. Campo de un Arco Delgado</p>
                    <p>El campo en el centro de un arco de radio $a$ y apertura $\alpha$ es:</p>
                    <p class="text-center my-1 p-2 border border-slate-200 dark:border-slate-700 rounded-md">
                        $$d\vec{E} = \frac{2 k_e \lambda}{a} \sin\left(\frac{\alpha}{2}\right) (-\hat{i})$$
                    </p>
                    <p class="font-semibold text-base">2. Anillo Diferencial</p>
                    <p>Para un anillo delgado de grosor $da$, la densidad lineal $\lambda$ es $\sigma da$. Sustituyendo en la fórmula anterior, obtenemos el campo del anillo:</p>
                    <p class="text-center my-1 p-2 border border-slate-200 dark:border-slate-700 rounded-md">
                        $$d\vec{E} = \frac{2 k_e (\sigma da)}{a} \sin\left(\frac{\alpha}{2}\right) (-\hat{i})$$
                    </p>
                    <p class="font-semibold text-base">3. Integral para el Campo Total</p>
                    <p>Integramos el campo $dE$ de todos los anillos desde $r_1$ hasta $r_2$. Los términos constantes salen de la integral:</p>
                     <p class="text-center my-1 p-2 border border-slate-200 dark:border-slate-700 rounded-md">
                        $$\vec{E} = 2 k_e \sigma \sin\left(\frac{\alpha}{2}\right) \int_{r_1}^{r_2} \frac{da}{a} \, (-\hat{i})$$
                    </p>
                     <p class="font-semibold text-base">4. Resultado Final</p>
                      <p class="text-center my-1 p-2 border border-slate-200 dark:border-slate-700 rounded-md">
                        $$\vec{E} = 2 k_e \sigma \sin\left(\frac{\alpha}{2}\right) \ln\left(\frac{r_2}{r_1}\right) (-\hat{i})$$
                    </p>

                </div>
                
                <!-- Análisis Tab -->
                <div id="analisis" class="tab-content p-2 text-sm space-y-4">
                    <p class="font-semibold text-base">Tips Conceptuales</p>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong>Simetría:</strong> El campo neto siempre apunta a lo largo del eje de simetría (eje X en este caso). Las componentes verticales se cancelan.</li>
                        <li><strong>Máximo Campo:</strong> Para radios y carga fijos, el campo es máximo cuando el arco es un semicírculo ($\alpha = 180^\circ$), ya que $\sin(\alpha/2) = \sin(90^\circ) = 1$.</li>
                         <li><strong>Campo Cero:</strong> Si la apertura es de $360^\circ$ (un anillo completo), el campo en el centro es cero. ¡Compruébalo!</li>
                    </ul>

                    <p class="font-semibold text-base mt-4">Preguntas de Análisis</p>
                    <ol class="list-decimal list-inside space-y-2">
                       <li>Fija todos los parámetros y varía solo el ángulo. ¿Por qué el campo disminuye después de los 180°?</li>
                       <li>Si $r_1$ se hace muy cercano a $r_2$, ¿el ángulo de apertura importa tanto como la separación de los radios?</li>
                    </ol>

                    <div class="mt-6">
                        <p class="font-semibold text-base">Desafío Numérico</p>
                        <div class="mt-2 p-3 border border-blue-200 dark:border-blue-800 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                            <p class="font-semibold my-2">Calcula el campo eléctrico total $|\vec{E}|$ en el origen para la siguiente configuración:</p>
                            <ul class="list-disc list-inside my-2 pl-4">
                                <li>Radio interno $r_1 = 1.5$ m</li>
                                <li>Radio externo $r_2 = 3.0$ m</li>
                                <li>Apertura del arco $\alpha = 120^\circ$</li>
                                <li>Densidad superficial $\sigma = -4.0$ nC/m²</li>
                            </ul>
                            <p class="mt-2 text-xs text-slate-500 dark:text-slate-400">
                                <strong>Pista:</strong> Usa los sliders para ajustar cada valor. ¡El panel de "Datos" te mostrará el resultado! (Recuerda que la magnitud del campo es siempre positiva).
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </aside>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- ELEMENTOS DEL DOM ---
    const canvas = document.getElementById('simulationCanvas');
    const ctx = canvas.getContext('2d');
    const canvasParent = document.getElementById('canvas-parent');
    
    // Controles
    const r1Slider = document.getElementById('r1Slider');
    const r1Value = document.getElementById('r1Value');
    const r2Slider = document.getElementById('r2Slider');
    const r2Value = document.getElementById('r2Value');
    const angleSlider = document.getElementById('angleSlider');
    const angleValue = document.getElementById('angleValue');
    const densitySlider = document.getElementById('densitySlider');
    const densityValue = document.getElementById('densityValue');
    const vectorScaleSlider = document.getElementById('vectorScaleSlider');
    const vectorScaleValue = document.getElementById('vectorScaleValue');
    const chargeSignBtn = document.getElementById('chargeSignBtn');
    const resetBtn = document.getElementById('resetBtn');

    // Valores dinámicos
    const aValueEl = document.getElementById('aValue');
    const dqValueEl = document.getElementById('dqValue');
    const dEValueEl = document.getElementById('dEValue');
    const QValueEl = document.getElementById('QValue');
    const EtotalValueEl = document.getElementById('EtotalValue');

    // --- CONSTANTES Y ESTADO DE LA SIMULACIÓN ---
    const k = 8.9875517923e9;
    const DA_WIDTH = 0.05; // Grosor visual/de cálculo para el anillo diferencial
    const initialState = {
        r1: 1.0,
        r2: 2.5,
        openingAngle: Math.PI, // 180 degrees
        sigma: 5.0, // nC/m^2
        chargeSign: 1,
        vectorScale: 1.0,
        zoom: 100,
        a_pos: 1.75, // Radio del anillo diferencial
    };
    let state = { ...initialState };
    let calculatedFields = {};

    let isDraggingA = false;
    let origin = { x: 0, y: 0 };
    
    // --- LÓGICA DE CÁLCULO ---
    function calculateFields() {
        const sigma = state.sigma * 1e-9 * state.chargeSign;
        const { r1, r2, a_pos, openingAngle } = state;
        
        if (r1 >= r2) {
             calculatedFields = { E_total: 0, Q_total: 0, dq: 0, dE: 0 };
             return;
        }

        const sinFactor = Math.sin(openingAngle / 2);

        // Total Field (Resultado Analítico)
        const E_total = 2 * k * sigma * sinFactor * Math.log(r2 / r1);
        
        // Total Charge
        const totalArea = (openingAngle / 2) * (r2*r2 - r1*r1);
        const Q_total = sigma * totalArea;

        // Differential Ring fields
        const dA = openingAngle * a_pos * DA_WIDTH;
        const dq = sigma * dA;
        const dE = 2 * k * sigma * sinFactor * Math.log((a_pos + DA_WIDTH/2) / (a_pos - DA_WIDTH/2));

        calculatedFields = { E_total, Q_total, dq, dE };
    }
    
    function updateDataPanel() {
        const { E_total, Q_total, dq, dE } = calculatedFields;
        aValueEl.textContent = state.a_pos.toFixed(2);
        dqValueEl.textContent = dq.toExponential(2);
        dEValueEl.textContent = Math.abs(dE).toExponential(2);
        QValueEl.textContent = Q_total.toExponential(2);
        EtotalValueEl.textContent = Math.abs(E_total).toExponential(2);
    }
    
    // --- LÓGICA DE DIBUJO EN EL CANVAS ---
    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvasParent.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;
        origin.x = rect.width / 2;
        origin.y = rect.height / 2;
        updateSimulation();
    }

    function worldToCanvas(pos) {
        return {
            x: origin.x + pos.x * state.zoom,
            y: origin.y - pos.y * state.zoom,
        };
    }

    function canvasToWorld(pos) {
        // Solo nos interesa la distancia radial para arrastrar 'a'
        return Math.hypot(pos.x - origin.x, pos.y - origin.y) / state.zoom;
    }

    function drawGrid() {
        const isDark = document.documentElement.classList.contains('dark');
        const axisColor = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
        
        ctx.strokeStyle = axisColor; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, canvas.height / (window.devicePixelRatio||1)); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(canvas.width / (window.devicePixelRatio||1), origin.y); ctx.stroke();
        ctx.lineWidth = 1;
    }

    function drawAnnulus() {
        const { r1, r2, openingAngle } = state;
        const chargeColor = state.chargeSign > 0 ? 'rgba(239, 68, 68, 0.4)' : 'rgba(59, 130, 246, 0.4)';
        
        const r1_canvas = r1 * state.zoom;
        const r2_canvas = r2 * state.zoom;
        const halfAngle = openingAngle / 2;

        ctx.fillStyle = chargeColor;
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, r2_canvas, -halfAngle, halfAngle);
        ctx.arc(origin.x, origin.y, r1_canvas, halfAngle, -halfAngle, true);
        ctx.closePath();
        ctx.fill();
    }

    function drawDifferentialRing() {
        const { a_pos, openingAngle } = state;
        const diffRingColor = '#f59e0b'; // Amber-500
        
        const a_canvas = a_pos * state.zoom;
        const halfAngle = openingAngle / 2;

        ctx.strokeStyle = diffRingColor;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, a_canvas, -halfAngle, halfAngle);
        ctx.stroke();
        
        // Etiqueta 'da'
        const labelAngle = Math.min(halfAngle, Math.PI / 4); // Posicionar etiqueta
        const labelPos = {
            x: (a_pos + 0.2) * Math.cos(labelAngle),
            y: (a_pos + 0.2) * Math.sin(labelAngle)
        };
        const labelCanvasPos = worldToCanvas(labelPos);
        const textColor = document.documentElement.classList.contains('dark') ? '#e2e8f0' : '#1e2b3b';
        ctx.fillStyle = textColor;
        ctx.font = '14px Inter';
        ctx.fillText('da', labelCanvasPos.x, labelCanvasPos.y);

        ctx.lineWidth = 1;
    }

    function drawVectors() {
        const originCanvas = worldToCanvas({x:0, y:0});
        const { E_total, dE } = calculatedFields;
        const vectorDrawScale = 0.01 * state.vectorScale * state.zoom;
        
        const direction = state.openingAngle > Math.PI ? -1 : 1;

        // Vector total
        const colorTotal = '#a855f7'; // Purple
        drawArrow(originCanvas.x, originCanvas.y, E_total * vectorDrawScale * direction, 0, colorTotal, 4, 'E');

        // Vector diferencial
        const colorDiff = '#f59e0b'; // Amber
        drawArrow(originCanvas.x, originCanvas.y, dE * vectorDrawScale * direction, 0, colorDiff, 2, 'dE');
    }

    function drawArrow(fromx, fromy, dx, dy, color, lineWidth, label) {
        if (Math.hypot(dx, dy) < 1) return;
        
        // El campo siempre apunta en -i si la carga es positiva
        const final_dx = state.chargeSign > 0 ? -Math.abs(dx) : Math.abs(dx);

        const tox = fromx + final_dx;
        const toy = fromy + dy;
        const headlen = 8;
        const angle = Math.atan2(toy - fromy, tox - fromx);

        ctx.strokeStyle = color; ctx.lineWidth = lineWidth; ctx.fillStyle = color;
        ctx.beginPath(); ctx.moveTo(fromx, fromy); ctx.lineTo(tox, toy); ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(tox, toy);
        ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
        ctx.closePath(); ctx.fill();
        ctx.fillStyle = color; ctx.font = '14px Inter';
        ctx.fillText(label, tox - (final_dx > 0 ? -5 : 20), toy + 15);
    }
    
    function draw() {
        const isDark = document.documentElement.classList.contains('dark');
        const bgColor = isDark ? '#0f172a' : '#f8fafc';
        const rect = canvasParent.getBoundingClientRect();
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, rect.width, rect.height);
        
        drawGrid();
        drawAnnulus();
        drawDifferentialRing();
        drawVectors();
    }
    
    function updateSimulation() {
        calculateFields();
        updateDataPanel();
        draw();
    }

    function handleInputChange() {
        state.r1 = parseFloat(r1Slider.value);
        state.r2 = parseFloat(r2Slider.value);
        state.openingAngle = parseFloat(angleSlider.value) * Math.PI / 180;
        
        // Ensure r1 < r2
        if (state.r1 >= state.r2) {
            state.r1 = state.r2 - 0.1;
            r1Slider.value = state.r1.toFixed(1);
        }
        
        state.sigma = parseFloat(densitySlider.value);
        state.vectorScale = parseFloat(vectorScaleSlider.value);
        
        r1Value.textContent = state.r1.toFixed(1);
        r2Value.textContent = state.r2.toFixed(1);
        angleValue.textContent = angleSlider.value;
        densityValue.textContent = state.sigma.toFixed(1);
        vectorScaleValue.textContent = state.vectorScale.toFixed(1);

        // Clamp a_pos
        state.a_pos = Math.max(state.r1, Math.min(state.r2, state.a_pos));

        updateSimulation();
        if (window.MathJax) MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }

    function resetSimulation() {
        state = { ...initialState };
        r1Slider.value = state.r1;
        r2Slider.value = state.r2;
        angleSlider.value = state.openingAngle * 180 / Math.PI;
        densitySlider.value = state.sigma;
        vectorScaleSlider.value = state.vectorScale;
        
        chargeSignBtn.classList.remove('bg-blue-500'); chargeSignBtn.classList.add('bg-red-500');
        chargeSignBtn.textContent = 'Carga Positiva';
        handleInputChange();
    }
    
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }

    canvas.addEventListener('mousedown', (e) => {
        const mousePos = getMousePos(e);
        const radius = canvasToWorld(mousePos);
        const halfAngle = state.openingAngle / 2;
        const angle = Math.atan2(mousePos.y - origin.y, mousePos.x - origin.x);
        
        if (radius >= state.r1 && radius <= state.r2 && Math.abs(angle) < halfAngle) {
             isDraggingA = true;
             state.a_pos = radius;
             updateSimulation();
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isDraggingA) return;
        const radius = canvasToWorld(getMousePos(e));
        state.a_pos = Math.max(state.r1, Math.min(state.r2, radius));
        updateSimulation();
    });

    ['mouseup', 'mouseleave'].forEach(evt => canvas.addEventListener(evt, () => {
        isDraggingA = false;
    }));
    
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            const tabId = button.dataset.tab;
            tabButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            tabContents.forEach(content => {
                content.id === tabId ? content.classList.add('active') : content.classList.remove('active');
            });
            if (window.MathJax) MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
        });
    });

    document.getElementById('theme-toggle').addEventListener('change', () => {
        document.documentElement.classList.toggle('dark');
        updateSimulation();
    });
    
    [r1Slider, r2Slider, angleSlider, densitySlider, vectorScaleSlider].forEach(s => s.addEventListener('input', handleInputChange));
    resetBtn.addEventListener('click', resetSimulation);
    chargeSignBtn.addEventListener('click', () => {
        state.chargeSign *= -1;
        const isPositive = state.chargeSign > 0;
        chargeSignBtn.textContent = isPositive ? 'Carga Positiva' : 'Carga Negativa';
        chargeSignBtn.classList.toggle('bg-red-500', isPositive);
        chargeSignBtn.classList.toggle('bg-blue-500', !isPositive);
        updateSimulation();
    });

    window.addEventListener('resize', resizeCanvas);
    resetSimulation();
    resizeCanvas();
    document.querySelector('.tab-button[data-tab="controles"]').click();
});
</script>
</body>
</html>
